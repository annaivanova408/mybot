<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>–ü—Ä–æ–≥–Ω–æ–∑ —Ç–æ—á–∫–∏</title>
  <style>
    body {
      margin: 0;
      background: #111;
      color: #fff;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;      /* –≥—Ä–∞—Ñ–∏–∫ –ø—Ä–∏–∂–∞—Ç –∫ –≤–µ—Ä—Ö—É */
      height: 100vh;
      padding-top: 16px;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
    }
    canvas {
      width: 95vw;                      /* –ø–æ—á—Ç–∏ –≤—Å—è —à–∏—Ä–∏–Ω–∞ —ç–∫—Ä–∞–Ω–∞ */
      max-width: 1000px;                /* –≤–µ—Ä—Ö–Ω–∏–π –ø—Ä–µ–¥–µ–ª –ø–æ —à–∏—Ä–∏–Ω–µ */
      height: 60vh;                     /* –±–æ–ª—å—à–∞—è —á–∞—Å—Ç—å –≤—ã—Å–æ—Ç—ã */
      max-height: 600px;
      background: #fff;
      margin-bottom: 12px;
      border-radius: 8px;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.35);
    }
    .hint {
      font-size: 14px;
      color: #ccc;
      text-align: center;
      padding: 0 16px 8px 16px;
    }
  </style>

  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <script>
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è WebApp
    Telegram.WebApp.ready();
    Telegram.WebApp.expand();
    Telegram.WebApp.setHeaderColor("dark");
    Telegram.WebApp.setBackgroundColor("#111");
    Telegram.WebApp.setViewportHeight(1200);
  </script>
</head>
<body>
  <canvas id="plot" width="1000" height="600"></canvas>

  <div class="hint" id="status">
    –ö–ª–∏–∫–Ω–∏ –ø–æ –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ–π –ª–∏–Ω–∏–∏ —Å–ø—Ä–∞–≤–∞, –≥–¥–µ, –ø–æ —Ç–≤–æ–µ–º—É –º–Ω–µ–Ω–∏—é, –±—É–¥–µ—Ç —Å–ª–µ–¥—É—é—â–∞—è —Ç–æ—á–∫–∞ —Ä—è–¥–∞.
  </div>

  <script>
    // --- –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –∏–∑ URL (–Ω–∞–ø—Ä–∏–º–µ—Ä, ?phi=0.7) ---
    const params = new URLSearchParams(window.location.search);
    const phi = parseFloat(params.get("phi")) || 0.5;

    // --- –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä –Ω–æ—Ä–º–∞–ª—å–Ω–æ–≥–æ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è (Box‚ÄìMuller) ---
    function randn() {
      const u = 1 - Math.random();
      const v = 1 - Math.random();
      return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
    }

    function generateAR1(n, phi, sigma) {
      const eps = [];
      for (let i = 0; i < n; i++) eps.push(sigma * randn());
      const X = [eps[0]];
      for (let t = 1; t < n; t++) {
        X.push(phi * X[t-1] + eps[t]);
      }
      return X;
    }

    // --- –î–∞–Ω–Ω—ã–µ –∏ –±–∞–∑–æ–≤—ã–µ –æ–±—ä–µ–∫—Ç—ã ---
    const n = 100;          // –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ñ–∞–∫—Ç–∏—á–µ—Å–∫–∏—Ö —Ç–æ—á–µ–∫
    const sigma = 0.5;
    const data = generateAR1(n, phi, sigma);

    const canvas = document.getElementById("plot");
    const ctx = canvas.getContext("2d");
    const statusDiv = document.getElementById("status");

    const pad = 40;                             // –æ—Ç—Å—Ç—É–ø—ã –æ—Ç –∫—Ä–∞—ë–≤
    const W = canvas.width - 2 * pad;
    const H = canvas.height - 2 * pad;

    const min = Math.min(...data);
    const max = Math.max(...data);
    const lastValue = data[data.length - 1];

    // --- –®–∫–∞–ª—ã ---
    function yScale(v) {
      if (max === min) return canvas.height / 2;
      return pad + H * (1 - (v - min) / (max - min));
    }

    function invYScale(y) {
      const ratio = (y - pad) / H;
      const clamped = Math.min(1, Math.max(0, ratio));
      return min + (1 - clamped) * (max - min);
    }

    function xCoord(i, total) {
      // i = 0..total, total = n (–ø–æ—Å–ª–µ–¥–Ω—è—è —Ñ–∞–∫—Ç–∏—á–µ—Å–∫–∞—è —Ç–æ—á–∫–∞ ‚Äî i=n-1, –ø—Ä–æ–≥–Ω–æ–∑ ‚Äî i=n)
      return pad + W * (i / total);
    }

    const predIndex = n;             // –∏–Ω–¥–µ–∫—Å —Ç–æ—á–∫–∏ –ø—Ä–æ–≥–Ω–æ–∑–∞ (—Å–ª–µ–¥—É—é—â–∏–π –ø–µ—Ä–∏–æ–¥)
    const xPred = xCoord(predIndex, n); // x-–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞ –ª–∏–Ω–∏–∏ –ø—Ä–æ–≥–Ω–æ–∑–∞

    // --- –†–∏—Å–æ–≤–∞–Ω–∏–µ ---
    function drawSeries(highlightPoint) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // –æ—Å—å X
      ctx.strokeStyle = "#ccc";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(pad, canvas.height - pad);
      ctx.lineTo(canvas.width - pad, canvas.height - pad);
      ctx.stroke();

      // –ª–∏–Ω–∏—è –ø—Ä–æ—Ü–µ—Å—Å–∞ (0..n-1)
      ctx.strokeStyle = "#4b6cff";
      ctx.lineWidth = 2;
      ctx.beginPath();
      for (let i = 0; i < n; i++) {
        const x = xCoord(i, n);
        const y = yScale(data[i]);
        if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
      }
      ctx.stroke();

      // –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–∞—è –ª–∏–Ω–∏—è –¥–ª—è —Ç–æ—á–∫–∏ –ø—Ä–æ–≥–Ω–æ–∑–∞
      ctx.strokeStyle = "#999";
      ctx.setLineDash([6, 6]);
      ctx.beginPath();
      ctx.moveTo(xPred, pad);
      ctx.lineTo(xPred, canvas.height - pad);
      ctx.stroke();
      ctx.setLineDash([]);

      // –ø–æ–¥–ø–∏—Å–∏
      ctx.fillStyle = "#000";
      ctx.font = "20px system-ui";
      ctx.fillText("AR(1), œÜ = " + phi.toFixed(2), pad, pad - 10);

      ctx.font = "14px system-ui";
      ctx.fillText("–ö–ª–∏–∫–Ω–∏ –∑–¥–µ—Å—å ‚Üí", xPred - 100, pad + 24);

      // –µ—Å–ª–∏ –µ—Å—Ç—å —Ç–æ—á–∫–∞ –ø—Ä–æ–≥–Ω–æ–∑–∞ –¥–ª—è –ø–æ–¥—Å–≤–µ—Ç–∫–∏
      if (highlightPoint) {
        const { x, y, up } = highlightPoint;
        ctx.fillStyle = up ? "#2ecc71" : "#e74c3c";
        ctx.beginPath();
        ctx.arc(x, y, 7, 0, 2 * Math.PI);
        ctx.fill();
      }
    }

    // –ø–µ—Ä–≤—ã–π —Ä–µ–Ω–¥–µ—Ä
    drawSeries(null);

    // --- –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–ª–∏–∫–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ---
    canvas.addEventListener("click", function (evt) {
      const rect = canvas.getBoundingClientRect();
      const x = evt.clientX - rect.left;
      const y = evt.clientY - rect.top;

      // –ø—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∫–ª–∏–∫–Ω—É–ª–∏ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –±–ª–∏–∑–∫–æ –∫ –ª–∏–Ω–∏–∏ –ø—Ä–æ–≥–Ω–æ–∑–∞
      const tolerance = 40; // –ø–∏–∫—Å–µ–ª–∏
      if (Math.abs(x - xPred) > tolerance) {
        statusDiv.textContent = "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∫–ª–∏–∫–Ω–∏ –ø–æ –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–æ–π –ª–∏–Ω–∏–∏ —Å–ø—Ä–∞–≤–∞ (—Å–ª–µ–¥—É—é—â–∞—è —Ç–æ—á–∫–∞).";
        return;
      }

      // –ø–µ—Ä–µ–≤–æ–¥–∏–º –ø–∏–∫—Å–µ–ª—å–Ω—É—é –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—É –≤ –∑–Ω–∞—á–µ–Ω–∏–µ —Ä—è–¥–∞ –∏ —Å—Ä–∞–≤–Ω–∏–≤–∞–µ–º —Å –ø–æ—Å–ª–µ–¥–Ω–µ–π —Ç–æ—á–∫–æ–π
      const predictedValue = invYScale(y);
      const up = predictedValue > lastValue; // true = —Ä–æ—Å—Ç

      // –ø–µ—Ä–µ—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º –≥—Ä–∞—Ñ–∏–∫ —Å –ø–æ–¥—Å–≤–µ—Ç–∫–æ–π —Ç–æ—á–∫–∏
      drawSeries({ x: xPred, y, up });

      statusDiv.textContent = up
        ? "–¢—ã –æ–∂–∏–¥–∞–µ—à—å —Ä–æ—Å—Ç —Ü–µ–Ω—ã üìà"
        : "–¢—ã –æ–∂–∏–¥–∞–µ—à—å –ø–∞–¥–µ–Ω–∏–µ —Ü–µ–Ω—ã üìâ";

      // –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ (1 = –≤–≤–µ—Ä—Ö, 0 = –≤–Ω–∏–∑)
      const answer = up ? "1" : "0";
      Telegram.WebApp.sendData(answer);
      // –ø–æ—Å–ª–µ —ç—Ç–æ–≥–æ –º–∏–Ω–∏-–∞–ø–ø –∑–∞–∫—Ä–æ–µ—Ç—Å—è –ø–æ –ø—Ä–∞–≤–∏–ª–∞–º Telegram
    });
  </script>
</body>
</html>