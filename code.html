<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Прогноз точки</title>
  <style>
    body {
      margin: 0;
      background: #111;
      color: #fff;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      height: 100vh;
      padding-top: 8px;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
    }

    .scroll-wrapper {
      width: 100vw;
      overflow-x: scroll;
      overflow-y: hidden;
      -webkit-overflow-scrolling: touch;
      background: #111;
    }

    canvas {
      width: 2200px;               /* ширина графика на экране */
      height: 500px;
      background: #fff;
      margin: 0 auto;
      display: block;
      border-radius: 8px;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.35);
    }

    .hint {
      font-size: 14px;
      color: #ccc;
      text-align: center;
      padding: 6px 16px 4px 16px;
      min-height: 40px;
    }

    .slider-wrapper {
      width: 100vw;
      padding: 0 16px 8px 16px;
      box-sizing: border-box;
    }

    input[type="range"] {
      width: 100%;
    }

    .actions {
      padding-bottom: 10px;
    }

    .send-btn {
      padding: 10px 20px;
      border-radius: 8px;
      border: none;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      background: #3498db;
      color: #fff;
      opacity: 0.4;
    }

    .send-btn.enabled {
      opacity: 1;
    }
  </style>

  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <script>
    Telegram.WebApp.ready();
    Telegram.WebApp.expand();
    Telegram.WebApp.setHeaderColor("dark");
    Telegram.WebApp.setBackgroundColor("#111");
    Telegram.WebApp.setViewportHeight(1200);
  </script>
</head>
<body>
  <div class="scroll-wrapper" id="scrollWrapper">
    <canvas id="plot"></canvas>
  </div>

  <div class="hint" id="status">
    Пролистай график вправо и кликни по вертикальной линии, где, по твоему мнению, будет следующая точка ряда (1 из 10).
  </div>

  <div class="slider-wrapper">
    <input type="range" id="scrollSlider" min="0" max="100" value="0">
  </div>

  <div class="actions">
    <button id="sendBtn" class="send-btn" disabled>Отправить результаты</button>
  </div>

  <script>
    // --- Параметры из URL (например, ?phi=0.7) ---
    const params = new URLSearchParams(window.location.search);
    const phi = parseFloat(params.get("phi")) || 0.5;

    const EXTRA_STEPS = 10;      // количество прогнозов
    const BASE_N = 100;          // длина исходного "исторического" ряда
    const TOTAL_N = BASE_N + EXTRA_STEPS;

    // --- Генератор нормального распределения (Box–Muller) ---
    function randn() {
      const u = 1 - Math.random();
      const v = 1 - Math.random();
      return Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
    }

    function generateAR1(n, phi, sigma) {
      const eps = [];
      for (let i = 0; i < n; i++) eps.push(sigma * randn());
      const X = [eps[0]];
      for (let t = 1; t < n; t++) {
        X.push(phi * X[t-1] + eps[t]);
      }
      return X;
    }

    // --- Данные ---
    const sigma = 0.5;
    const data = generateAR1(TOTAL_N, phi, sigma);

    // --- Canvas и размеры ---
    const canvas = document.getElementById("plot");
    const ctx = canvas.getContext("2d");

    // реальные размеры полотна (в пикселях)
    canvas.width  = 2200;
    canvas.height = 500;

    const pad = 40;
    const W = canvas.width - 2 * pad;
    const H = canvas.height - 2 * pad;

    const min = Math.min(...data);
    const max = Math.max(...data);

    // --- Шкалы ---
    function yScale(v) {
      if (max === min) return canvas.height / 2;
      return pad + H * (1 - (v - min) / (max - min));
    }

    function invYScale(y) {
      const ratio = (y - pad) / H;
      const clamped = Math.min(1, Math.max(0, ratio));
      return min + (1 - clamped) * (max - min);
    }

    function xCoord(i) {
      // i = 0..TOTAL_N
      return pad + W * (i / TOTAL_N);
    }

    // --- Состояние эксперимента ---
    let currentStep = 0;              // 0..EXTRA_STEPS-1
    let maxRealIndex = BASE_N - 1;    // последний "открытый" индекс истинного ряда
    const predictions = [];           // массив всех прогнозов

    const statusDiv = document.getElementById("status");
    const wrapper = document.getElementById("scrollWrapper");
    const slider = document.getElementById("scrollSlider");
    const sendBtn = document.getElementById("sendBtn");

    // --- Рисование ---
    function drawSeries() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // ось X
      ctx.strokeStyle = "#ccc";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(pad, canvas.height - pad);
      ctx.lineTo(canvas.width - pad, canvas.height - pad);
      ctx.stroke();

      // истинная линия процесса: рисуем только открытую часть
      ctx.strokeStyle = "#4b6cff";
      ctx.lineWidth = 2;
      ctx.beginPath();
      for (let i = 0; i <= maxRealIndex; i++) {
        const x = xCoord(i);
        const y = yScale(data[i]);
        if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
      }
      ctx.stroke();

      // вертикальная линия для текущего прогноза, если ещё есть шаги
      if (currentStep < EXTRA_STEPS) {
        const predIndex = BASE_N + currentStep;
        const xPred = xCoord(predIndex);

        ctx.strokeStyle = "#999";
        ctx.setLineDash([6, 6]);
        ctx.beginPath();
        ctx.moveTo(xPred, pad);
        ctx.lineTo(xPred, canvas.height - pad);
        ctx.stroke();
        ctx.setLineDash([]);

        ctx.fillStyle = "#000";
        ctx.font = "14px system-ui";
        ctx.fillText("Кликни здесь →", xPred - 110, pad + 24);
      }

      // подпись phi
      ctx.fillStyle = "#000";
      ctx.font = "20px system-ui";
      ctx.fillText("AR(1), φ = " + phi.toFixed(2), pad, pad - 10);

      // рисуем все прогнозные крестики
      for (const p of predictions) {
        const x = xCoord(p.t);
        const y = yScale(p.y_pred);

        ctx.strokeStyle = "#e67e22";
        ctx.lineWidth = 2;
        const size = 7;
        ctx.beginPath();
        ctx.moveTo(x - size, y - size);
        ctx.lineTo(x + size, y + size);
        ctx.moveTo(x - size, y + size);
        ctx.lineTo(x + size, y - size);
        ctx.stroke();

        // при желании можно подписывать шаг
        ctx.font = "12px system-ui";
        ctx.fillStyle = "#e67e22";
        ctx.fillText(`P${p.step+1}`, x + 6, y - 8);
      }
    }

    // первый рендер
    drawSeries();

    // --- Бегунок <-> скролл ---
    function updateSliderFromScroll() {
      const maxScroll = wrapper.scrollWidth - wrapper.clientWidth;
      if (maxScroll <= 0) {
        slider.value = 0;
        return;
      }
      const ratio = wrapper.scrollLeft / maxScroll;
      slider.value = ratio * 100;
    }

    function updateScrollFromSlider() {
      const maxScroll = wrapper.scrollWidth - wrapper.clientWidth;
      const ratio = slider.value / 100;
      wrapper.scrollLeft = maxScroll * ratio;
    }

    slider.addEventListener("input", updateScrollFromSlider);
    wrapper.addEventListener("scroll", updateSliderFromScroll);

    // чуть-чуть сдвигаем вправо при старте, чтобы было видно, что график длинный
    setTimeout(() => {
      slider.value = 100;
      updateScrollFromSlider();
    }, 300);

    // --- Обработка клика пользователя ---
    canvas.addEventListener("click", function (evt) {
      if (currentStep >= EXTRA_STEPS) {
        statusDiv.textContent = "Все 10 прогнозов уже сделаны. Можешь отправить результаты.";
        return;
      }

      const rect = canvas.getBoundingClientRect();
      const x = evt.clientX - rect.left;
      const y = evt.clientY - rect.top;

      const predIndex = BASE_N + currentStep;
      const xPred = xCoord(predIndex);

      const tolerance = 40; // требуем попасть в зону вокруг вертикальной линии
      if (Math.abs(x - xPred) > tolerance) {
        statusDiv.textContent = "Пожалуйста, пролистай вправо и кликни по вертикальной линии (следующая точка).";
        return;
      }

      // переводим пиксель в значение
      const yValue = invYScale(y);
      const trueValue = data[predIndex];
      const up = yValue > data[predIndex - 1];   // "ожидается рост?" — относительно предыдущего значения

      // фиксируем, что реальная точка тоже открылась
      maxRealIndex = predIndex;

      predictions.push({
        step: currentStep,
        t: predIndex,
        y_pred: yValue,
        y_true: trueValue,
        up: up
      });

      currentStep += 1;

      drawSeries();

      if (currentStep < EXTRA_STEPS) {
        statusDiv.textContent =
          `Прогноз ${currentStep} сделан. Сейчас t = ${predIndex}, твой y ≈ ${yValue.toFixed(2)}, ` +
          `истинное y ≈ ${trueValue.toFixed(2)}. Сделай прогноз ${currentStep+1} из ${EXTRA_STEPS}.`;
      } else {
        statusDiv.textContent =
          `Все ${EXTRA_STEPS} прогнозов сделаны. Последняя точка: t = ${predIndex}, ` +
          `твой y ≈ ${yValue.toFixed(2)}, истинное y ≈ ${trueValue.toFixed(2)}. ` +
          `Теперь нажми «Отправить результаты».`;
        sendBtn.disabled = false;
        sendBtn.classList.add("enabled");
      }
    });

    // --- Отправка результатов в бота (один раз, после 10 шагов) ---
    sendBtn.addEventListener("click", function () {
      if (predictions.length < EXTRA_STEPS) {
        statusDiv.textContent = "Сначала сделай все 10 прогнозов, потом отправляй результаты.";
        return;
      }

      const payload = {
        phi: phi,
        base_n: BASE_N,
        extra_steps: EXTRA_STEPS,
        predictions: predictions
      };

      Telegram.WebApp.sendData(JSON.stringify(payload));
      // после этого мини-апп закроется
    });
  </script>
</body>
</html>